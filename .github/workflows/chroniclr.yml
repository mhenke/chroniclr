name: Chroniclr Documentation Generator

run-name: >
  ðŸ“š ${{
    (github.event.inputs.doc_type && format('Documentation ({0})', github.event.inputs.doc_type)) ||
    github.event.discussion.title ||
    github.event.inputs.discussion_number && 'Discussion Documentation' ||
    github.event.inputs.pr_numbers && 'PR Documentation' ||
    github.event.inputs.jira_keys && 'Jira Documentation' ||
    'Generated Documentation'
  }}${{
    github.event.discussion.number && format(' (#{0})', github.event.discussion.number) ||
    github.event.inputs.discussion_number && format(' (#{0})', github.event.inputs.discussion_number) || ''
  }}${{
    github.event.inputs.pr_numbers && format(' â€¢ PR#{0}', github.event.inputs.pr_numbers) || ''
  }}${{
    github.event.inputs.jira_keys && format(' â€¢ {0}', github.event.inputs.jira_keys) || ''
  }}

on:
  discussion:
    types: [created, edited]

  workflow_dispatch:
    inputs:
      discussion_number:
        description: 'Discussion number to process'
        required: false
        type: string
      source:
        description: 'Data sources: discussion,pr,jira (auto-detected if not specified)'
        required: false
        type: string
      pr_numbers:
        description: 'Pull request numbers (comma-separated, e.g., "123,456")'
        required: false
        type: string
      jira_keys:
        description: 'Jira issue keys (comma-separated, e.g., "PROJ-123,PROJ-456")'
        required: false
        type: string
      doc_type:
        description: 'Document type to generate (e.g., "summary,meeting-notes,sprint-status,pr-report")'
        required: false
        type: string

permissions:
  contents: write
  discussions: read
  pull-requests: write
  models: read

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    concurrency:
      group: chroniclr-docs-${{ github.event_name }}-${{ github.event.discussion.number || github.event.inputs.discussion_number || 'manual' }}
      cancel-in-progress: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          show-progress: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Get discussion details
        id: discussion
        uses: actions/github-script@v7
        with:
          script: |
            const discussionNumber = context.payload.discussion?.number || 
                                    context.payload.inputs?.discussion_number;
            
            // Auto-detect source modules based on provided inputs
            let sourceModules = context.payload.inputs?.source;
            if (!sourceModules) {
              const sources = [];
              if (discussionNumber) sources.push('discussion');
              if (context.payload.inputs?.pr_numbers) sources.push('pr');
              if (context.payload.inputs?.jira_keys) sources.push('jira');
              if (context.payload.inputs?.issue_numbers) sources.push('issues');
              
              // Debug logging
              core.info(`ðŸ” Debug: discussionNumber=${discussionNumber}`);
              core.info(`ðŸ” Debug: pr_numbers=${context.payload.inputs?.pr_numbers}`);
              core.info(`ðŸ” Debug: jira_keys=${context.payload.inputs?.jira_keys}`);
              core.info(`ðŸ” Debug: issue_numbers=${context.payload.inputs?.issue_numbers}`);
              core.info(`ðŸ” Debug: detected sources=[${sources.join(', ')}]`);
              
              sourceModules = sources.length > 0 ? sources.join(',') : 'discussion';
              core.info(`ðŸ” Debug: final sourceModules=${sourceModules}`);
            }

            // Only require discussion number if 'discussion' is in the source modules
            if (!discussionNumber && sourceModules.includes('discussion')) {
              core.setFailed('Discussion number is required when source includes "discussion"');
              return;
            }

            // Skip discussion processing if no discussion number provided
            if (!discussionNumber) {
              core.info('No discussion number provided - skipping discussion data processing');
              core.setOutput('number', '');
              core.setOutput('title', 'Generated Documentation');
              core.setOutput('body', '');
              core.setOutput('full_content', '');
              core.setOutput('comments_count', 0);
              core.setOutput('labels', '[]');
              core.setOutput('author', 'system');
              core.setOutput('url', '');
              return;
            }

            // Get discussion details
            let discussion;
            try {
              const response = await github.request(
                'GET /repos/{owner}/{repo}/discussions/{discussion_number}',
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  discussion_number: Number(discussionNumber)
                }
              );
              discussion = response.data;
            } catch (error) {
              if (error.status === 404) {
                core.setFailed(`Discussion #${discussionNumber} not found. Please check the discussion number and try again.`);
                return;
              } else {
                core.setFailed(`Failed to fetch discussion #${discussionNumber}: ${error.message}`);
                return;
              }
            }

            // Get discussion comments using GraphQL
            const commentsQuery = `
              query($owner: String!, $name: String!, $number: Int!) {
                repository(owner: $owner, name: $name) {
                  discussion(number: $number) {
                    comments(first: 50) {
                      nodes {
                        author {
                          login
                        }
                        body
                        createdAt
                        updatedAt
                      }
                    }
                  }
                }
              }
            `;

            let comments = [];
            try {
              const commentsResult = await github.graphql(commentsQuery, {
                owner: context.repo.owner,
                name: context.repo.repo,
                number: Number(discussionNumber)
              });
              
              comments = commentsResult.repository.discussion.comments.nodes || [];
              core.info(`Found ${comments.length} comments for discussion #${discussionNumber}`);
            } catch (error) {
              core.warning(`Failed to fetch comments: ${error.message}`);
            }

            // Combine discussion body with comments for AI processing
            let fullContent = discussion.body;
            if (comments.length > 0) {
              fullContent += '\n\n--- DISCUSSION COMMENTS ---\n\n';
              comments.forEach((comment, index) => {
                fullContent += `**Comment ${index + 1} by @${comment.author.login} (${comment.createdAt}):**\n`;
                fullContent += comment.body + '\n\n';
              });
            }


            core.setOutput('number', discussion.number);
            core.setOutput('title', discussion.title);
            core.setOutput('body', discussion.body);
            core.setOutput('full_content', fullContent);
            core.setOutput('comments_count', comments.length);
            core.setOutput('labels', JSON.stringify(discussion.labels || []));
            core.setOutput('author', discussion.user.login);
            core.setOutput('url', discussion.html_url);

      - name: Validate discussion data
        if: ${{ contains(github.event.inputs.source || 'discussion', 'discussion') }}
        env:
          DISCUSSION_NUMBER: ${{ steps.discussion.outputs.number }}
          DISCUSSION_TITLE: ${{ steps.discussion.outputs.title }}
          DISCUSSION_BODY: ${{ steps.discussion.outputs.body }}
          DISCUSSION_AUTHOR: ${{ steps.discussion.outputs.author }}
          DISCUSSION_URL: ${{ steps.discussion.outputs.url }}
        run: npm run validate-discussion

      - name: Validate additional resources
        id: validate-resources
        uses: actions/github-script@v7
        with:
          script: |
            // Auto-detect source modules based on provided inputs
            let sourceModules = context.payload.inputs?.source;
            if (!sourceModules) {
              const sources = [];
              if (context.payload.inputs?.discussion_number) sources.push('discussion');
              if (context.payload.inputs?.pr_numbers) sources.push('pr');
              if (context.payload.inputs?.jira_keys) sources.push('jira');
              if (context.payload.inputs?.issue_numbers) sources.push('issues');
              sourceModules = sources.length > 0 ? sources.join(',') : 'discussion';
            }
            
            const prNumbers = context.payload.inputs?.pr_numbers;
            const issueNumbers = context.payload.inputs?.issue_numbers;
            const jiraKeys = context.payload.inputs?.jira_keys;

            // Validate Pull Requests if specified
            if (sourceModules.includes('pr') && prNumbers) {
              const prArray = prNumbers.split(',').map(n => n.trim()).filter(n => n);
              for (const prNumber of prArray) {
                try {
                  await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: parseInt(prNumber)
                  });
                  core.info(`âœ… Validated PR #${prNumber}`);
                } catch (error) {
                  if (error.status === 404) {
                    core.setFailed(`Pull Request #${prNumber} not found. Please check the PR number and try again.`);
                    return;
                  } else {
                    core.setFailed(`Failed to validate PR #${prNumber}: ${error.message}`);
                    return;
                  }
                }
              }
            }

            // Validate Issues if specified
            if (sourceModules.includes('issues') && issueNumbers) {
              const issueArray = issueNumbers.split(',').map(n => n.trim()).filter(n => n);
              for (const issueNumber of issueArray) {
                try {
                  await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parseInt(issueNumber)
                  });
                  core.info(`âœ… Validated Issue #${issueNumber}`);
                } catch (error) {
                  if (error.status === 404) {
                    core.setFailed(`Issue #${issueNumber} not found. Please check the issue number and try again.`);
                    return;
                  } else {
                    core.setFailed(`Failed to validate Issue #${issueNumber}: ${error.message}`);
                    return;
                  }
                }
              }
            }

            // Note for Jira validation: Jira validation would require Jira API credentials
            // and is handled in the Node.js code during data collection
            if (sourceModules.includes('jira') && jiraKeys) {
              core.info(`Jira keys provided: ${jiraKeys} - validation will occur during document generation`);
            }

            core.info('âœ… All specified resources validated successfully');
            core.setOutput('source_modules', sourceModules);
            core.info(`ðŸ”§ Auto-detected source modules: ${sourceModules}`);

      - name: Determine document types
        id: doc-types
        env:
          DISCUSSION_LABELS: ${{ steps.discussion.outputs.labels }}
          DOC_TYPE: ${{ github.event.inputs.doc_type }}
        run: |
          if [ -n "$DOC_TYPE" ]; then
            echo "Using specified document type(s): $DOC_TYPE"
            echo "document_types=$DOC_TYPE" >> $GITHUB_OUTPUT
          else
            echo "Processing labels to determine document types"
            npm run process-labels
          fi

      - name: Generate documentation
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DOC_TYPE: ${{ steps.doc-types.outputs.document_types }}
          SOURCE_MODULES: ${{ steps.validate-resources.outputs.source_modules || github.event.inputs.source || 'jira' }}
          PR_NUMBERS: ${{ github.event.inputs.pr_numbers }}
          JIRA_KEYS: ${{ github.event.inputs.jira_keys }}
          # Jira API credentials
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT: ${{ secrets.JIRA_PROJECT }}
          DISCUSSION_NUMBER: ${{ steps.discussion.outputs.number }}
          DISCUSSION_TITLE: ${{ steps.discussion.outputs.title }}
          DISCUSSION_BODY: ${{ steps.discussion.outputs.body }}
          DISCUSSION_AUTHOR: ${{ steps.discussion.outputs.author }}
          DISCUSSION_URL: ${{ steps.discussion.outputs.url }}
          DISCUSSION_COMMENTS_COUNT: ${{ steps.discussion.outputs.comments_count }}
          # Rate limiting strategy - prefer templates for large workloads
          PREFER_TEMPLATES: ${{ steps.doc-types.outputs.document_types && contains(steps.doc-types.outputs.document_types, ' ') && 'true' || 'false' }}
        run: npm run generate-document

      - name: Ensure labels exist
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const labels = [
              { name: 'documentation', color: '0075ca', description: 'Documentation updates' },
              { name: 'automated', color: '5319e7', description: 'Created by automation' },
              { name: 'chroniclr', color: '0e8a16', description: 'Chroniclr generated' },
            ];

            for (const l of labels) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: l.name,
                });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: l.name,
                    color: l.color,
                    description: l.description,
                  });
                  core.info(`Created label: ${l.name}`);
                }
              }
            }

      - name: Generate deterministic branch name
        id: branch-name
        uses: actions/github-script@v7
        with:
          script: |
            const discussionNumber = context.payload.inputs?.discussion_number || 
                                   context.payload.discussion?.number || '';
            const sources = context.payload.inputs?.source || 'discussion';
            const prNumbers = context.payload.inputs?.pr_numbers || '';
            const jiraKeys = context.payload.inputs?.jira_keys || '';

            // Create a hash-like identifier from the inputs to ensure branch name uniqueness
            let branchSuffix = '';
            if (discussionNumber) branchSuffix += `d${discussionNumber}`;
            if (sources !== 'discussion') branchSuffix += `-src${sources.replace(/,/g, '_')}`;
            if (prNumbers) branchSuffix += `-pr${prNumbers.replace(/,/g, '_')}`;
            if (jiraKeys) branchSuffix += `-jira${jiraKeys.replace(/,/g, '_')}`;

            // Fallback for manual runs without specific parameters
            if (!branchSuffix) {
              branchSuffix = `manual-${Date.now().toString().slice(-6)}`;
            }

            const branchName = `docs/chroniclr-${branchSuffix}`;
            core.setOutput('name', branchName);
            core.info(`Generated branch name: ${branchName}`);

      - name: Create Pull Request
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: 'ðŸ“š Generate documentation via Chroniclr [skip ci]'
          title: >
            ðŸ“š ${{
              (steps.doc-types.outputs.document_types && format('Documentation ({0})', steps.doc-types.outputs.document_types)) ||
              steps.discussion.outputs.title ||
              (github.event.inputs.pr_numbers && 'PR Documentation') ||
              (github.event.inputs.jira_keys && 'Jira Documentation') ||
              'Generated Documentation'
            }}${{
              steps.discussion.outputs.number && format(' (#{0})', steps.discussion.outputs.number) ||
              github.event.inputs.discussion_number && format(' (#{0})', github.event.inputs.discussion_number) || ''
            }}${{
              github.event.inputs.pr_numbers && format(' â€¢ PR#{0}', github.event.inputs.pr_numbers) || ''
            }}${{
              github.event.inputs.jira_keys && format(' â€¢ {0}', github.event.inputs.jira_keys) || ''
            }}
          body: |
            ## Automated Documentation Update

            This PR contains documentation automatically generated by Chroniclr.

            **Data Sources:** ${{ github.event.inputs.source || 'discussion' }}
            **Document Types:** ${{ steps.doc-types.outputs.document_types }}

            ### Source Details
            ${{ steps.discussion.outputs.number && format('- Discussion #{0}: {1}', steps.discussion.outputs.number, steps.discussion.outputs.title) || '' }}
            ${{ steps.discussion.outputs.author && format('- Author: @{0}', steps.discussion.outputs.author) || '' }}
            ${{ github.event.inputs.pr_numbers && format('- PRs: {0}', github.event.inputs.pr_numbers) || '' }}
            ${{ github.event.inputs.jira_keys && format('- Jira: {0}', github.event.inputs.jira_keys) || '' }}

            ### Generated Files
            - Documents are organized in `generated/` folder by date and topic
            - AI-enhanced generation with template fallbacks
            - Automatic topic extraction from content

            ðŸ¤– **Automated PR by Chroniclr**
          branch: ${{ steps.branch-name.outputs.name }}
          delete-branch: true
          labels: |
            documentation
            automated
            chroniclr
