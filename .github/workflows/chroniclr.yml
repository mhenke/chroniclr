name: Chroniclr Documentation Generator

on:
  discussion:
    types: [created, edited]

  workflow_dispatch:
    inputs:
      discussion_number:
        description: 'Discussion number to process'
        required: false
        type: string
      source:
        description: 'Data sources (comma-separated: discussion,issues,pr,jira)'
        required: false
        type: string
        default: 'discussion'
      pr_numbers:
        description: 'Pull request numbers (comma-separated, e.g., "123,456")'
        required: false
        type: string
      jira_keys:
        description: 'Jira issue keys (comma-separated, e.g., "PROJ-123,PROJ-456")'
        required: false
        type: string
      issue_numbers:
        description: 'GitHub issue numbers (comma-separated, e.g., "123,456")'
        required: false
        type: string

permissions:
  contents: write
  discussions: read
  pull-requests: write
  models: read

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    concurrency:
      group: chroniclr-docs-${{ github.event_name }}-${{ github.event.discussion.number || github.event.inputs.discussion_number || 'manual' }}
      cancel-in-progress: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Get discussion details
        id: discussion
        uses: actions/github-script@v7
        with:
          script: |
            const discussionNumber = context.payload.discussion?.number || 
                                    context.payload.inputs?.discussion_number;
            const sourceModules = context.payload.inputs?.source || 'discussion';

            // Only require discussion number if 'discussion' is in the source modules
            if (!discussionNumber && sourceModules.includes('discussion')) {
              core.setFailed('Discussion number is required when source includes "discussion"');
              return;
            }

            // Skip discussion processing if no discussion number provided
            if (!discussionNumber) {
              core.info('No discussion number provided - skipping discussion data processing');
              core.setOutput('number', '');
              core.setOutput('title', 'Generated Documentation');
              core.setOutput('body', '');
              core.setOutput('full_content', '');
              core.setOutput('comments_count', 0);
              core.setOutput('labels', '[]');
              core.setOutput('author', 'system');
              core.setOutput('url', '');
              return;
            }

            // Get discussion details
            let discussion;
            try {
              const response = await github.request(
                'GET /repos/{owner}/{repo}/discussions/{discussion_number}',
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  discussion_number: Number(discussionNumber)
                }
              );
              discussion = response.data;
            } catch (error) {
              if (error.status === 404) {
                core.setFailed(`Discussion #${discussionNumber} not found. Please check the discussion number and try again.`);
                return;
              } else {
                core.setFailed(`Failed to fetch discussion #${discussionNumber}: ${error.message}`);
                return;
              }
            }

            // Get discussion comments using GraphQL
            const commentsQuery = `
              query($owner: String!, $name: String!, $number: Int!) {
                repository(owner: $owner, name: $name) {
                  discussion(number: $number) {
                    comments(first: 50) {
                      nodes {
                        author {
                          login
                        }
                        body
                        createdAt
                        updatedAt
                      }
                    }
                  }
                }
              }
            `;

            let comments = [];
            try {
              const commentsResult = await github.graphql(commentsQuery, {
                owner: context.repo.owner,
                name: context.repo.repo,
                number: Number(discussionNumber)
              });
              
              comments = commentsResult.repository.discussion.comments.nodes || [];
              core.info(`Found ${comments.length} comments for discussion #${discussionNumber}`);
            } catch (error) {
              core.warning(`Failed to fetch comments: ${error.message}`);
            }

            // Combine discussion body with comments for AI processing
            let fullContent = discussion.body;
            if (comments.length > 0) {
              fullContent += '\n\n--- DISCUSSION COMMENTS ---\n\n';
              comments.forEach((comment, index) => {
                fullContent += `**Comment ${index + 1} by @${comment.author.login} (${comment.createdAt}):**\n`;
                fullContent += comment.body + '\n\n';
              });
            }


            core.setOutput('number', discussion.number);
            core.setOutput('title', discussion.title);
            core.setOutput('body', discussion.body);
            core.setOutput('full_content', fullContent);
            core.setOutput('comments_count', comments.length);
            core.setOutput('labels', JSON.stringify(discussion.labels || []));
            core.setOutput('author', discussion.user.login);
            core.setOutput('url', discussion.html_url);

      - name: Validate discussion data
        env:
          DISCUSSION_NUMBER: ${{ steps.discussion.outputs.number }}
          DISCUSSION_TITLE: ${{ steps.discussion.outputs.title }}
          DISCUSSION_BODY: ${{ steps.discussion.outputs.body }}
          DISCUSSION_AUTHOR: ${{ steps.discussion.outputs.author }}
          DISCUSSION_URL: ${{ steps.discussion.outputs.url }}
        run: npm run validate-discussion

      - name: Validate additional resources
        id: validate-resources
        uses: actions/github-script@v7
        with:
          script: |
            const sourceModules = context.payload.inputs?.source || 'discussion';
            const prNumbers = context.payload.inputs?.pr_numbers;
            const issueNumbers = context.payload.inputs?.issue_numbers;
            const jiraKeys = context.payload.inputs?.jira_keys;

            // Validate Pull Requests if specified
            if (sourceModules.includes('pr') && prNumbers) {
              const prArray = prNumbers.split(',').map(n => n.trim()).filter(n => n);
              for (const prNumber of prArray) {
                try {
                  await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: parseInt(prNumber)
                  });
                  core.info(`✅ Validated PR #${prNumber}`);
                } catch (error) {
                  if (error.status === 404) {
                    core.setFailed(`Pull Request #${prNumber} not found. Please check the PR number and try again.`);
                    return;
                  } else {
                    core.setFailed(`Failed to validate PR #${prNumber}: ${error.message}`);
                    return;
                  }
                }
              }
            }

            // Validate Issues if specified
            if (sourceModules.includes('issues') && issueNumbers) {
              const issueArray = issueNumbers.split(',').map(n => n.trim()).filter(n => n);
              for (const issueNumber of issueArray) {
                try {
                  await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parseInt(issueNumber)
                  });
                  core.info(`✅ Validated Issue #${issueNumber}`);
                } catch (error) {
                  if (error.status === 404) {
                    core.setFailed(`Issue #${issueNumber} not found. Please check the issue number and try again.`);
                    return;
                  } else {
                    core.setFailed(`Failed to validate Issue #${issueNumber}: ${error.message}`);
                    return;
                  }
                }
              }
            }

            // Note for Jira validation: Jira validation would require Jira API credentials
            // and is handled in the Node.js code during data collection
            if (sourceModules.includes('jira') && jiraKeys) {
              core.info(`Jira keys provided: ${jiraKeys} - validation will occur during document generation`);
            }

            core.info('✅ All specified resources validated successfully');

      - name: Determine document types
        id: doc-types
        env:
          DISCUSSION_LABELS: ${{ steps.discussion.outputs.labels }}
        run: npm run process-labels

      - name: Generate documentation
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DOC_TYPE: ${{ steps.doc-types.outputs.document_types }}
          SOURCE_MODULES: ${{ github.event.inputs.source || 'discussion' }}
          PR_NUMBERS: ${{ github.event.inputs.pr_numbers }}
          JIRA_KEYS: ${{ github.event.inputs.jira_keys }}
          ISSUE_NUMBERS: ${{ github.event.inputs.issue_numbers }}
          DISCUSSION_NUMBER: ${{ steps.discussion.outputs.number }}
          DISCUSSION_TITLE: ${{ steps.discussion.outputs.title }}
          DISCUSSION_BODY: ${{ steps.discussion.outputs.body }}
          DISCUSSION_AUTHOR: ${{ steps.discussion.outputs.author }}
          DISCUSSION_URL: ${{ steps.discussion.outputs.url }}
          DISCUSSION_COMMENTS_COUNT: ${{ steps.discussion.outputs.comments_count }}
          # Rate limiting strategy - prefer templates for large workloads
          PREFER_TEMPLATES: ${{ steps.doc-types.outputs.document_types && contains(steps.doc-types.outputs.document_types, ' ') && 'true' || 'false' }}
        run: |
          echo "🚀 Starting documentation generation..."
          echo "📊 Processing document types: $DOC_TYPE"
          echo "📝 Template preference: $PREFER_TEMPLATES"
          npm run generate-document

      - name: Ensure labels exist
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const labels = [
              { name: 'documentation', color: '0075ca', description: 'Documentation updates' },
              { name: 'automated', color: '5319e7', description: 'Created by automation' },
              { name: 'chroniclr', color: '0e8a16', description: 'Chroniclr generated' },
            ];

            for (const l of labels) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: l.name,
                });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: l.name,
                    color: l.color,
                    description: l.description,
                  });
                  core.info(`Created label: ${l.name}`);
                }
              }
            }

      - name: Generate deterministic branch name
        id: branch-name
        uses: actions/github-script@v7
        with:
          script: |
            const discussionNumber = context.payload.inputs?.discussion_number || 
                                   context.payload.discussion?.number || '';
            const sources = context.payload.inputs?.source || 'discussion';
            const prNumbers = context.payload.inputs?.pr_numbers || '';
            const issueNumbers = context.payload.inputs?.issue_numbers || '';
            const jiraKeys = context.payload.inputs?.jira_keys || '';

            // Create a hash-like identifier from the inputs to ensure branch name uniqueness
            let branchSuffix = '';
            if (discussionNumber) branchSuffix += `d${discussionNumber}`;
            if (sources !== 'discussion') branchSuffix += `-src${sources.replace(/,/g, '_')}`;
            if (prNumbers) branchSuffix += `-pr${prNumbers.replace(/,/g, '_')}`;
            if (issueNumbers) branchSuffix += `-iss${issueNumbers.replace(/,/g, '_')}`;
            if (jiraKeys) branchSuffix += `-jira${jiraKeys.replace(/,/g, '_')}`;

            // Fallback for manual runs without specific parameters
            if (!branchSuffix) {
              branchSuffix = `manual-${Date.now().toString().slice(-6)}`;
            }

            const branchName = `docs/chroniclr-${branchSuffix}`;
            core.setOutput('name', branchName);
            core.info(`Generated branch name: ${branchName}`);

      - name: Create Pull Request
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: '📚 Generate documentation via Chroniclr'
          title: "${{ format('📚 {0}', steps.discussion.outputs.title || 'Update documentation via Chroniclr') }}"
          body: |
            ## Automated Documentation Update

            This PR contains documentation automatically generated by Chroniclr using AI (GitHub Models GPT-4o).

            ### Source Information
            **Data Sources:** ${{ github.event.inputs.source || 'discussion' }}
            **Document Types Generated:** ${{ steps.doc-types.outputs.document_types }}

            #### Discussion Details
            ${{ steps.discussion.outputs.number && format('- **Discussion #{0}:** {1}', steps.discussion.outputs.number, steps.discussion.outputs.title) || '- No discussion processed' }}
            ${{ steps.discussion.outputs.author && format('- **Author:** @{0}', steps.discussion.outputs.author) || '' }}
            ${{ steps.discussion.outputs.comments_count && format('- **Comments Processed:** {0}', steps.discussion.outputs.comments_count) || '' }}
            ${{ steps.discussion.outputs.url && format('- **Discussion URL:** {0}', steps.discussion.outputs.url) || '' }}

            #### Additional Sources
            ${{ github.event.inputs.pr_numbers && format('- **Pull Requests:** {0}', github.event.inputs.pr_numbers) || '' }}
            ${{ github.event.inputs.issue_numbers && format('- **Issues:** {0}', github.event.inputs.issue_numbers) || '' }}
            ${{ github.event.inputs.jira_keys && format('- **Jira Tickets:** {0}', github.event.inputs.jira_keys) || '' }}

            ### Generated Documents
            - All documents are organized in topic-based folders under `generated/`
            - AI-generated content with template fallbacks
            - Comprehensive source attribution and metadata
            - Cross-referenced with original discussions, PRs, and issues

            ### Process Details
            - **AI Model:** GitHub Models GPT-4o
            - **Generation Method:** ${{ steps.doc-types.outputs.document_types && 'Bundled multi-document generation' || 'Single document generation' }}
            - **Template System:** Markdown templates with variable substitution
            - **Quality Assurance:** Automatic fallback to structured templates if AI generation fails

            ### 🔍 Content Traceability & Compliance
            **Content Source Classification:**
            - 🔍 **EXTRACTED** - Content parsed directly from source materials (discussions, PRs, issues)
            - 🧠 **INFERRED** - Content derived from available data using algorithms
            - 📝 **GENERATED** - Structured fallback content when source data insufficient

            **Audit Trail:** Each document includes detailed source attribution and processing metadata in `generation-metadata.md`

            **Compliance Features:**
            - Complete source traceability for all generated content
            - Content authenticity scoring (% of extracted vs. generated content)
            - Pattern matching evidence for extracted information
            - Processing timestamps and environment details

            ---
            🤖 **This PR was automatically created by Chroniclr**

            📋 **Supporting Documents:** Check the `generated/` folder for a detailed `generation-metadata.md` file containing comprehensive information about sources, processing details, and document lineage.

            🔍 **Audit Information:** See `/docs/Content-Traceability.md` for complete traceability methodology and compliance guidelines.

            > **Note:** Re-running the same workflow parameters will update this PR instead of creating a new one.
          branch: ${{ steps.branch-name.outputs.name }}
          delete-branch: true
          labels: |
            documentation
            automated
            chroniclr
