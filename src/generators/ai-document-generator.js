#!/usr/bin/env node

/**
 * AI Document Generator using GitHub Models API
 * Replaces Claude Code with built-in GitHub AI models
 */

const core = require('@actions/core');
const fs = require('fs').promises;
const path = require('path');

class AIDocumentGenerator {
  constructor() {
    this.baseURL = "https://models.inference.ai.azure.com";
    this.apiKey = process.env.GITHUB_TOKEN;
    this.model = "gpt-4o";
  }

  async generateCompletion(prompt) {
    const response = await fetch(`${this.baseURL}/chat/completions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: this.model,
        messages: [
          {
            role: "system",
            content: "You are a professional documentation generator. Create well-structured, comprehensive documents based on GitHub discussion content."
          },
          {
            role: "user", 
            content: prompt
          }
        ],
        max_tokens: 4000,
        temperature: 0.3
      })
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  }

  async loadTemplate(templateType) {
    const templatePath = path.join(__dirname, '..', 'templates', `${templateType}.md`);
    try {
      return await fs.readFile(templatePath, 'utf8');
    } catch (error) {
      core.warning(`Template not found: ${templatePath}`);
      return this.getDefaultTemplate(templateType);
    }
  }

  getDefaultTemplate(templateType) {
    const templates = {
      'summary': `# {title}

## Overview
{overview}

## Key Points
{keyPoints}

## Action Items
{actionItems}

## Participants
{participants}

---
*This document was automatically generated by Chroniclr from GitHub discussion #{discussionNumber}*`,

      'initiative-brief': `# Initiative: {title}

## Problem Statement
{problemStatement}

## Proposed Solution
{proposedSolution}

## Timeline
{timeline}

## Resources Required
{resources}

## Success Criteria
{successCriteria}

---
*This document was automatically generated by Chroniclr from GitHub discussion #{discussionNumber}*`,

      'meeting-notes': `# Meeting Notes: {title}

**Date:** {date}
**Attendees:** {participants}

## Agenda
{agenda}

## Discussion Points
{discussionPoints}

## Decisions Made
{decisions}

## Action Items
{actionItems}

## Next Steps
{nextSteps}

---
*This document was automatically generated by Chroniclr from GitHub discussion #{discussionNumber}*`,

      'changelog': `# Changelog Entry

## Version {version}
**Release Date:** {date}

### Added
{addedFeatures}

### Changed
{changedFeatures}

### Fixed
{fixedIssues}

---
*This document was automatically generated by Chroniclr from GitHub discussion #{discussionNumber}*`
    };

    return templates[templateType] || templates['summary'];
  }

  async generateDocument(docType, discussionData) {
    const template = await this.loadTemplate(docType);
    
    const prompt = `
Based on the following GitHub discussion, generate a ${docType} document using this template structure:

Template:
${template}

Discussion Details:
- Title: ${discussionData.title}
- Author: ${discussionData.author}
- URL: ${discussionData.url}
- Content:
${discussionData.body}

Instructions:
1. Extract relevant information from the discussion content
2. Fill in the template variables with appropriate content
3. Maintain professional tone and clear structure
4. Include specific details, action items, and key decisions
5. Replace {discussionNumber} with ${discussionData.number}
6. Return only the final document content, no explanations

Generate the ${docType} document now:
`;

    try {
      const generatedContent = await this.generateCompletion(prompt);
      return generatedContent;
    } catch (error) {
      core.error(`Failed to generate ${docType}: ${error.message}`);
      throw error;
    }
  }

  async saveDocument(docType, content, discussionNumber) {
    const outputDir = path.join(process.cwd(), 'docs');
    await fs.mkdir(outputDir, { recursive: true });
    
    const filename = `${docType}-${discussionNumber}.md`;
    const filepath = path.join(outputDir, filename);
    
    await fs.writeFile(filepath, content, 'utf8');
    core.info(`Generated: ${filepath}`);
    
    return filepath;
  }
}

async function main() {
  try {
    const docType = process.env.DOC_TYPE || core.getInput('doc-type');
    const discussionNumber = process.env.DISCUSSION_NUMBER || core.getInput('discussion-number');
    const discussionTitle = process.env.DISCUSSION_TITLE || core.getInput('discussion-title');
    const discussionBody = process.env.DISCUSSION_BODY || core.getInput('discussion-body');
    const discussionAuthor = process.env.DISCUSSION_AUTHOR || core.getInput('discussion-author');
    const discussionUrl = process.env.DISCUSSION_URL || core.getInput('discussion-url');

    if (!docType || !discussionNumber || !discussionTitle || !discussionBody) {
      core.setFailed('Missing required parameters');
      return;
    }

    const generator = new AIDocumentGenerator();
    
    const discussionData = {
      number: discussionNumber,
      title: discussionTitle,
      body: discussionBody,
      author: discussionAuthor,
      url: discussionUrl
    };

    core.info(`Generating ${docType} document for discussion #${discussionNumber}`);
    
    const content = await generator.generateDocument(docType, discussionData);
    const filepath = await generator.saveDocument(docType, content, discussionNumber);
    
    core.setOutput('filepath', filepath);
    core.setOutput('generated', 'true');
    
  } catch (error) {
    core.setFailed(`Document generation failed: ${error.message}`);
  }
}

if (require.main === module) {
  main();
}

module.exports = { AIDocumentGenerator };