#!/usr/bin/env node

/**
 * AI Document Generator using GitHub Models API
 * Replaces Claude Code with built-in GitHub AI models
 */

const core = require('@actions/core');
const fs = require('fs').promises;
const path = require('path');

class AIDocumentGenerator {
  constructor() {
    this.baseURL = "https://models.github.ai/inference";
    this.apiKey = process.env.GITHUB_TOKEN;
    this.model = "gpt-4o";
    
    // Log configuration for debugging
    core.info(`AI Generator initialized with model: ${this.model}`);
    core.info(`API endpoint: ${this.baseURL}/chat/completions`);
  }

  async generateCompletion(prompt) {
    try {
      core.info('Making AI API request...');
      
      const requestBody = {
        model: this.model,
        messages: [
          {
            role: "system",
            content: "You are a professional documentation generator. Create well-structured, comprehensive documents based on GitHub discussion content."
          },
          {
            role: "user", 
            content: prompt
          }
        ],
        max_tokens: 4000,
        temperature: 0.3
      };
      
      const response = await fetch(`${this.baseURL}/chat/completions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
          'Accept': 'application/vnd.github+json',
          'X-GitHub-Api-Version': '2022-11-28'
        },
        body: JSON.stringify(requestBody)
      });

      core.info(`API response status: ${response.status}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        core.error(`API request failed: ${response.status} ${response.statusText}`);
        core.error(`Response body: ${errorText}`);
        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      core.info('AI response received successfully');
      
      if (!data.choices || !data.choices[0] || !data.choices[0].message) {
        core.error('Invalid API response structure');
        core.error(`Response: ${JSON.stringify(data, null, 2)}`);
        throw new Error('Invalid API response structure');
      }
      
      return data.choices[0].message.content;
      
    } catch (error) {
      core.error(`AI API call failed: ${error.message}`);
      // Instead of failing, return a fallback structured document
      return this.generateFallbackDocument(prompt);
    }
  }
  
  generateFallbackDocument(prompt) {
    core.warning('Using fallback document generation (no AI processing)');
    
    // Extract basic info from prompt for a structured fallback
    const lines = prompt.split('\n');
    const titleLine = lines.find(line => line.includes('Title:'));
    const title = titleLine ? titleLine.replace('Title:', '').trim() : 'Generated Document';
    
    return `# ${title}

## Overview
This document was generated from a GitHub discussion but AI processing is currently unavailable.

## Summary
Please refer to the original discussion for full details.

## Next Steps
- Review the source discussion
- Update this document with proper structure
- Contact administrators about AI service issues

---
*This document was generated by Chroniclr with fallback processing*`;
  }

  async loadTemplate(templateType) {
    const templatePath = path.join(__dirname, '..', 'templates', `${templateType}.md`);
    try {
      return await fs.readFile(templatePath, 'utf8');
    } catch (error) {
      core.warning(`Template not found: ${templatePath}`);
      return this.getDefaultTemplate(templateType);
    }
  }

  getDefaultTemplate(templateType) {
    const templates = {
      'summary': `# {title}

## Overview
{overview}

## Key Points
{keyPoints}

## Action Items
{actionItems}

## Participants
{participants}

---
*This document was automatically generated by Chroniclr from GitHub discussion #{discussionNumber}*`,

      'initiative-brief': `# Initiative: {title}

## Problem Statement
{problemStatement}

## Proposed Solution
{proposedSolution}

## Timeline
{timeline}

## Resources Required
{resources}

## Success Criteria
{successCriteria}

---
*This document was automatically generated by Chroniclr from GitHub discussion #{discussionNumber}*`,

      'meeting-notes': `# Meeting Notes: {title}

**Date:** {date}
**Attendees:** {participants}

## Agenda
{agenda}

## Discussion Points
{discussionPoints}

## Decisions Made
{decisions}

## Action Items
{actionItems}

## Next Steps
{nextSteps}

---
*This document was automatically generated by Chroniclr from GitHub discussion #{discussionNumber}*`,

      'changelog': `# Changelog Entry

## Version {version}
**Release Date:** {date}

### Added
{addedFeatures}

### Changed
{changedFeatures}

### Fixed
{fixedIssues}

---
*This document was automatically generated by Chroniclr from GitHub discussion #{discussionNumber}*`
    };

    return templates[templateType] || templates['summary'];
  }

  async generateDocument(docType, discussionData) {
    const template = await this.loadTemplate(docType);
    
    const prompt = `
Based on the following GitHub discussion, generate a ${docType} document using this template structure:

Template:
${template}

Discussion Details:
- Title: ${discussionData.title}
- Author: ${discussionData.author}
- URL: ${discussionData.url}
- Content:
${discussionData.body}

Instructions:
1. Extract relevant information from the discussion content
2. Fill in the template variables with appropriate content
3. Maintain professional tone and clear structure
4. Include specific details, action items, and key decisions
5. Replace {discussionNumber} with ${discussionData.number}
6. Return only the final document content, no explanations

Generate the ${docType} document now:
`;

    try {
      core.info(`Generating ${docType} document with AI...`);
      const generatedContent = await this.generateCompletion(prompt);
      
      // Validate that we got actual generated content, not just copied input
      if (generatedContent.includes(discussionData.body.substring(0, 100))) {
        core.warning('Generated content appears to be copied input - AI processing may have failed');
      }
      
      return generatedContent;
    } catch (error) {
      core.error(`Failed to generate ${docType}: ${error.message}`);
      
      // Return a basic structured document instead of failing completely
      const template = await this.loadTemplate(docType);
      return template
        .replace(/\{title\}/g, discussionData.title)
        .replace(/\{discussionNumber\}/g, discussionData.number)
        .replace(/\{.*?\}/g, '[AI processing unavailable]');
    }
  }

  async saveDocument(docType, content, discussionNumber) {
    const outputDir = path.join(process.cwd(), 'docs');
    await fs.mkdir(outputDir, { recursive: true });
    
    const filename = `${docType}-${discussionNumber}.md`;
    const filepath = path.join(outputDir, filename);
    
    await fs.writeFile(filepath, content, 'utf8');
    core.info(`Generated: ${filepath}`);
    
    return filepath;
  }
}

async function main() {
  try {
    const docType = process.env.DOC_TYPE || core.getInput('doc-type');
    const discussionNumber = process.env.DISCUSSION_NUMBER || core.getInput('discussion-number');
    const discussionTitle = process.env.DISCUSSION_TITLE || core.getInput('discussion-title');
    const discussionBody = process.env.DISCUSSION_BODY || core.getInput('discussion-body');
    const discussionAuthor = process.env.DISCUSSION_AUTHOR || core.getInput('discussion-author');
    const discussionUrl = process.env.DISCUSSION_URL || core.getInput('discussion-url');

    if (!docType || !discussionNumber || !discussionTitle || !discussionBody) {
      core.setFailed('Missing required parameters');
      return;
    }

    const generator = new AIDocumentGenerator();
    
    const discussionData = {
      number: discussionNumber,
      title: discussionTitle,
      body: discussionBody,
      author: discussionAuthor,
      url: discussionUrl
    };

    core.info(`Generating ${docType} document for discussion #${discussionNumber}`);
    
    const content = await generator.generateDocument(docType, discussionData);
    const filepath = await generator.saveDocument(docType, content, discussionNumber);
    
    core.setOutput('filepath', filepath);
    core.setOutput('generated', 'true');
    
  } catch (error) {
    core.setFailed(`Document generation failed: ${error.message}`);
  }
}

if (require.main === module) {
  main();
}

module.exports = { AIDocumentGenerator };