#!/usr/bin/env node

/**
 * Simplified AI Document Generator using GitHub Models API
 * Handles multi-source documentation generation
 */

const core = require('@actions/core');
const fs = require('fs').promises;
const path = require('path');
const { globalRequestQueue } = require('../utils/request-queue');
const { PullRequestClient } = require('../utils/pr-client');
const { IssuesClient } = require('../utils/issues-client');
const { JiraClient } = require('../utils/jira-client');

class AIDocumentGenerator {
  constructor() {
    this.baseURL = 'https://models.github.ai/inference';
    this.apiKey = process.env.GITHUB_TOKEN;
    this.model = 'gpt-4o';

    // Initialize data source clients
    this.prClient = new PullRequestClient();
    this.issuesClient = new IssuesClient();
    this.jiraClient = null; // Initialize lazily when needed

    core.info(`AI Generator initialized with model: ${this.model}`);
  }

  async sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  async generateCompletion(prompt) {
    const maxRetries = 3;
    const baseDelayMs = 1000;

    return globalRequestQueue.add(async () => {
      let attempt = 0;
      while (attempt <= maxRetries) {
        try {
          core.info(
            `Making AI API request... (attempt ${attempt + 1}/${
              maxRetries + 1
            })`
          );

          const requestBody = {
            model: this.model,
            messages: [
              {
                role: 'system',
                content:
                  'You are a professional documentation generator. Create well-structured, comprehensive documents based on the provided data sources.',
              },
              {
                role: 'user',
                content: prompt,
              },
            ],
            max_tokens: 4000,
            temperature: 0.3,
          };

          const response = await fetch(`${this.baseURL}/chat/completions`, {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${this.apiKey}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody),
          });

          if (!response.ok) {
            if (
              (response.status === 429 || response.status >= 500) &&
              attempt < maxRetries
            ) {
              const delayMs = baseDelayMs * Math.pow(2, attempt);
              core.warning(
                `Rate limit/Server error ${response.status}. Waiting ${delayMs}ms before retry...`
              );
              await this.sleep(delayMs);
              attempt++;
              continue;
            }

            core.error(
              `AI API request failed: ${response.status} ${response.statusText}`
            );
            return null;
          }

          const data = await response.json();
          if (data.choices && data.choices.length > 0) {
            core.info('AI response received successfully');
            return data.choices[0].message.content;
          } else {
            core.error('No AI response content received');
            return null;
          }
        } catch (error) {
          core.error(`AI API request error: ${error.message}`);
          if (attempt < maxRetries) {
            attempt++;
            await this.sleep(baseDelayMs * Math.pow(2, attempt));
            continue;
          }
          return null;
        }
      }
      return null;
    });
  }

  async loadTemplate(docType) {
    const templatePath = path.join(
      process.cwd(),
      'src',
      'templates',
      `${docType}.md`
    );

    try {
      const template = await fs.readFile(templatePath, 'utf8');
      return template;
    } catch (error) {
      core.warning(`Template not found for ${docType}, using basic template`);
      return this.getBasicTemplate(docType);
    }
  }

  getBasicTemplate(docType) {
    return `# {title}

**Date:** {date}
**Type:** ${docType}

## Content

{content}

## Summary

{summary}

---
*This document was automatically generated by Chroniclr*`;
  }

  getJiraClient() {
    if (!this.jiraClient) {
      this.jiraClient = new JiraClient();
    }
    return this.jiraClient;
  }

  async collectDataFromSources() {
    const sourceModules = (process.env.SOURCE_MODULES || 'discussion')
      .split(',')
      .map((s) => s.trim());
    const collectedData = {
      discussion: null,
      prs: [],
      issues: [],
      jiraIssues: [],
      sources: sourceModules,
    };

    // Collect Discussion Data
    if (sourceModules.includes('discussion') && process.env.DISCUSSION_NUMBER) {
      collectedData.discussion = {
        number: process.env.DISCUSSION_NUMBER,
        title: process.env.DISCUSSION_TITLE || 'Discussion',
        body: process.env.DISCUSSION_BODY || '',
        author: process.env.DISCUSSION_AUTHOR || 'unknown',
        url: process.env.DISCUSSION_URL || '',
        commentsCount: parseInt(process.env.COMMENTS_COUNT) || 0,
      };
      core.info(
        `✅ Collected discussion data: #${collectedData.discussion.number}`
      );
    }

    // Collect PR Data
    if (sourceModules.includes('pr') && process.env.PR_NUMBERS) {
      const prNumbers = process.env.PR_NUMBERS.split(',')
        .map((n) => n.trim())
        .filter((n) => n);
      collectedData.prs = await this.prClient.fetchPullRequests(prNumbers);
      core.info(`✅ Collected ${collectedData.prs.length} PRs`);
    }

    // Collect Issues Data
    if (sourceModules.includes('issues') && process.env.ISSUE_NUMBERS) {
      const issueNumbers = process.env.ISSUE_NUMBERS.split(',')
        .map((n) => n.trim())
        .filter((n) => n);
      collectedData.issues = await this.issuesClient.fetchIssues(issueNumbers);
      core.info(`✅ Collected ${collectedData.issues.length} issues`);
    }

    // Collect Jira Data
    if (sourceModules.includes('jira') && process.env.JIRA_KEYS) {
      const jiraClient = this.getJiraClient();
      const jiraKeys = process.env.JIRA_KEYS.split(',')
        .map((k) => k.trim())
        .filter((k) => k);
      collectedData.jiraIssues = await jiraClient.fetchJiraIssues(jiraKeys);

      // Also get current sprint if no specific keys provided
      if (jiraKeys.length === 0) {
        collectedData.currentSprint = await jiraClient.getCurrentSprint();
      }

      core.info(`✅ Collected ${collectedData.jiraIssues.length} Jira issues`);
    }

    return collectedData;
  }

  createBundledAIPrompt(docTypes, data, templates) {
    let prompt = `Generate multiple documents and determine a topic folder name from the following data sources:\n\n`;

    // Add all data sources
    if (data.discussion) {
      prompt += `## Discussion Data\n`;
      prompt += `Title: ${data.discussion.title}\n`;
      prompt += `Author: ${data.discussion.author}\n`;
      prompt += `Comments: ${data.discussion.commentsCount || 0}\n`;
      prompt += `Content:\n${data.discussion.body}\n\n`;
    }

    if (data.prs && data.prs.length > 0) {
      prompt += `## Pull Requests (${data.prs.length})\n`;
      data.prs.forEach((pr, index) => {
        prompt += `PR ${index + 1}: ${pr.title} (#${pr.number})\n`;
        prompt += `Status: ${pr.status}, Author: ${pr.author}\n`;
        prompt += `Files: ${pr.files}, +${pr.additions}/-${pr.deletions}\n`;
        prompt += `Description: ${pr.body.substring(0, 200)}...\n\n`;
      });
    }

    if (data.issues && data.issues.length > 0) {
      prompt += `## GitHub Issues (${data.issues.length})\n`;
      data.issues.forEach((issue, index) => {
        prompt += `Issue ${index + 1}: ${issue.title} (#${issue.number})\n`;
        prompt += `Status: ${issue.status}, Labels: ${issue.labels.join(
          ', '
        )}\n\n`;
      });
    }

    if (data.jiraIssues && data.jiraIssues.length > 0) {
      prompt += `## Jira Issues (${data.jiraIssues.length})\n`;
      data.jiraIssues.forEach((issue, index) => {
        prompt += `- ${issue.key}: ${issue.summary}\n`;
      });
      prompt += '\n';
    }

    prompt += `Please generate the following ${docTypes.length} documents and provide a suitable topic folder name:\n\n`;

    docTypes.forEach((docType, index) => {
      prompt += `${
        index + 1
      }. **${docType.toUpperCase()}** using this template structure:\n`;
      prompt += `${templates[docType].substring(0, 500)}...\n\n`;
    });

    prompt += `Format your response as JSON:\n`;
    prompt += `{\n`;
    prompt += `  "topic": "topic-folder-name",\n`;
    prompt += `  "documents": {\n`;
    docTypes.forEach((docType, index) => {
      prompt += `    "${docType}": "document content here"${
        index < docTypes.length - 1 ? ',' : ''
      }\n`;
    });
    prompt += `  }\n`;
    prompt += `}\n`;

    return prompt;
  }

  createAIPrompt(docType, data, template) {
    let prompt = `Generate a ${docType} document using the following data sources:\n\n`;

    // Add discussion content
    if (data.discussion) {
      prompt += `## Discussion Data\n`;
      prompt += `Title: ${data.discussion.title}\n`;
      prompt += `Author: ${data.discussion.author}\n`;
      prompt += `Comments: ${data.discussion.commentsCount}\n`;
      prompt += `Content:\n${data.discussion.body}\n\n`;
    }

    // Add PR content
    if (data.prs.length > 0) {
      prompt += `## Pull Requests (${data.prs.length})\n`;
      data.prs.forEach((pr) => {
        prompt += `- PR #${pr.number}: ${pr.title} (${pr.author})\n`;
        prompt += `  Status: ${pr.state}, Merged: ${pr.merged}\n`;
        prompt += `  Files: ${pr.files.length}, Jira: ${pr.jiraKeys.join(
          ', '
        )}\n`;
      });
      prompt += `\n`;
    }

    // Add issues content
    if (data.issues.length > 0) {
      prompt += `## GitHub Issues (${data.issues.length})\n`;
      data.issues.forEach((issue) => {
        prompt += `- Issue #${issue.number}: ${issue.title} (${issue.author})\n`;
        prompt += `  Status: ${issue.state}, Labels: ${issue.labels
          .map((l) => l.name)
          .join(', ')}\n`;
      });
      prompt += `\n`;
    }

    // Add Jira content
    if (data.jiraIssues.length > 0) {
      prompt += `## Jira Issues (${data.jiraIssues.length})\n`;
      data.jiraIssues.forEach((issue) => {
        prompt += `- ${issue.key}: ${issue.summary}\n`;
        prompt += `  Status: ${issue.status}, Type: ${issue.issueType}, Assignee: ${issue.assignee}\n`;
      });
      prompt += `\n`;
    }

    prompt += `## Instructions\n`;
    prompt += `Please create a comprehensive ${docType} document that:\n`;
    prompt += `1. Synthesizes information from all provided sources\n`;
    prompt += `2. Follows the template structure provided\n`;
    prompt += `3. Extracts key insights, decisions, and action items\n`;
    prompt += `4. Creates clear sections and proper markdown formatting\n`;
    prompt += `5. Maintains professional documentation standards\n\n`;

    prompt += `## Template Structure\n${template}\n\n`;
    prompt += `Please replace template variables with appropriate content based on the data above.`;

    return prompt;
  }

  async generateDocument() {
    try {
      const docTypesString = process.env.DOC_TYPE || 'summary';
      const docTypes = docTypesString
        .split(' ')
        .map((type) => type.trim())
        .filter((type) => type);

      core.info(
        `Processing ${docTypes.length} document types: ${docTypes.join(', ')}`
      );

      // Collect data from all enabled sources
      const data = await this.collectDataFromSources();

      // Use bundled generation to reduce API calls
      if (docTypes.length > 1) {
        core.info('Using bundled AI generation for multiple documents...');
        return await this.generateBundledDocuments(docTypes, data);
      } else {
        core.info('Using single document generation...');
        const result = await this.generateSingleDocument(docTypes[0], data);
        return result ? [result] : [];
      }
    } catch (error) {
      core.error(`Document generation failed: ${error.message}`);
      throw error;
    }
  }

  async generateBundledDocuments(docTypes, data) {
    try {
      // Generate the folder name once for all documents in this request
      const sharedTopic = await this.generateAITopic(data);
      core.info(`Using shared topic/folder: ${sharedTopic}`);

      // Load all templates
      const templates = {};
      for (const docType of docTypes) {
        templates[docType] = await this.loadTemplate(docType);
      }

      // Create bundled AI prompt that generates all documents + topic in one call
      const bundledPrompt = await this.createBundledAIPrompt(
        docTypes,
        data,
        templates
      );

      // Single AI API call for all documents and topic
      core.info(
        `Making single AI API call for ${docTypes.length} documents and topic generation...`
      );
      const aiResponse = await this.generateCompletion(bundledPrompt);

      if (!aiResponse) {
        core.warning(
          'Bundled AI generation failed, falling back to individual templates'
        );
        return await this.generateFallbackDocuments(
          docTypes,
          data,
          templates,
          sharedTopic
        );
      }

      // Parse the bundled response
      const parsedResponse = this.parseBundledResponse(aiResponse, docTypes);

      // Use the AI-generated topic if available, otherwise fall back to shared topic
      const finalTopic = parsedResponse.topic || sharedTopic;

      // Save documents and return results
      const results = [];
      for (const docType of docTypes) {
        const content =
          parsedResponse.documents[docType] ||
          this.createFallbackContent(docType, data, templates[docType]);
        const result = await this.saveDocument(
          docType,
          data,
          content,
          finalTopic
        );
        if (result) {
          results.push(result);
        }
      }

      return results;
    } catch (error) {
      core.error(`Bundled generation failed: ${error.message}`);
      // Fallback to template generation with shared topic
      core.info('Falling back to template generation with shared topic...');
      const templates = {};
      for (const docType of docTypes) {
        templates[docType] = await this.loadTemplate(docType);
      }
      return await this.generateFallbackDocuments(
        docTypes,
        data,
        templates,
        sharedTopic
      );
    }
  }

  async generateFallbackDocuments(
    docTypes,
    data,
    templates,
    sharedTopic = null
  ) {
    core.info('Using fallback template generation...');
    const results = [];

    // Generate shared topic once if not provided
    const topic = sharedTopic || (await this.generateAITopic(data));
    core.info(
      `Using ${
        sharedTopic ? 'shared' : 'generated'
      } topic for fallback: ${topic}`
    );

    for (const docType of docTypes) {
      try {
        const content = this.createFallbackContent(
          docType,
          data,
          templates[docType]
        );
        const result = await this.saveDocument(docType, data, content, topic);
        if (result) {
          results.push(result);
        }
      } catch (error) {
        core.error(
          `Fallback generation failed for ${docType}: ${error.message}`
        );
      }
    }

    return results;
  }

  async generateSingleDocument(docType, data) {
    try {
      // Load template
      const template = await this.loadTemplate(docType);

      // Create AI prompt
      const prompt = this.createAIPrompt(docType, data, template);

      // Generate content with AI
      core.info(`Generating ${docType} document using AI...`);
      const aiContent = await this.generateCompletion(prompt);

      let finalContent;
      if (aiContent) {
        finalContent = aiContent;
      } else {
        core.warning('AI generation failed, using fallback template');
        finalContent = this.createFallbackContent(docType, data, template);
      }

      // Save document to AI-organized folder
      const baseOutputDir = path.join(process.cwd(), 'generated');
      const sourceFolder = await this.determineSourceFolder(data);
      const outputDir = path.join(baseOutputDir, sourceFolder);
      await fs.mkdir(outputDir, { recursive: true });

      const fileName = this.generateFileName(docType, data);
      const filePath = path.join(outputDir, fileName);

      await fs.writeFile(filePath, finalContent, 'utf8');

      core.info(`✅ Generated document: ${fileName}`);
      return { filePath, fileName, content: finalContent };
    } catch (error) {
      core.error(
        `Single document generation failed for ${docType}: ${error.message}`
      );
      return null;
    }
  }

  async saveDocument(docType, data, content, topic = null) {
    try {
      const baseOutputDir = path.join(process.cwd(), 'generated');

      let sourceFolder;
      if (topic) {
        // When topic is provided (bundled generation), create consistent folder name
        const today = new Date().toISOString().split('T')[0];
        sourceFolder = `${today}-${topic}`;
      } else {
        // Fallback to the original logic for individual generation
        sourceFolder = await this.determineSourceFolder(data);
      }

      const outputDir = path.join(baseOutputDir, sourceFolder);
      await fs.mkdir(outputDir, { recursive: true });

      const fileName = this.generateFileName(docType, data);
      const filePath = path.join(outputDir, fileName);

      await fs.writeFile(filePath, content, 'utf8');

      core.info(
        `✅ Generated document: ${fileName} in folder: ${sourceFolder}`
      );
      return { filePath, fileName, content };
    } catch (error) {
      core.error(`Failed to save ${docType} document: ${error.message}`);
      return null;
    }
  }

  parseBundledResponse(aiResponse, docTypes) {
    try {
      // Try to parse as JSON first
      const parsed = JSON.parse(aiResponse);
      if (parsed.topic && parsed.documents) {
        return parsed;
      }
    } catch (error) {
      core.warning(
        'Failed to parse AI response as JSON, attempting text parsing...'
      );
    }

    // Fallback: parse text response
    const result = {
      topic: 'generated-docs',
      documents: {},
    };

    // Extract topic from response
    const topicMatch = aiResponse.match(/topic[":]\s*["']?([^"',\n]+)["']?/i);
    if (topicMatch) {
      result.topic = topicMatch[1]
        .toLowerCase()
        .replace(/[^a-z0-9-]/g, '')
        .substring(0, 30);
    }

    // Extract documents by looking for document type markers
    docTypes.forEach((docType) => {
      const docTypePattern = new RegExp(
        `${docType}[":]*[^\\n]*\\n([\\s\\S]*?)(?=\\n\\s*(?:${docTypes.join(
          '|'
        )})[":]*|$)`,
        'i'
      );
      const match = aiResponse.match(docTypePattern);
      if (match) {
        result.documents[docType] = match[1].trim();
      } else {
        core.warning(`Could not extract ${docType} from AI response`);
        result.documents[docType] = null;
      }
    });

    return result;
  }

  async generateAITopic(data) {
    // Collect all content for AI analysis
    let content = '';
    if (data.discussion) content += `Discussion: "${data.discussion.title}" `;
    if (data.prs.length > 0)
      content += `PRs: ${data.prs.map((pr) => pr.title).join(', ')} `;
    if (data.issues.length > 0)
      content += `Issues: ${data.issues.map((i) => i.title).join(', ')} `;
    if (data.jiraIssues.length > 0)
      content += `Jira: ${data.jiraIssues.map((j) => j.summary).join(', ')} `;

    if (!content.trim()) return 'general';

    try {
      const topicPrompt = `Analyze this content and extract 1-3 specific theme words (maximum 20 characters total):

${content}

Be specific, not generic. Return ONLY 1-3 words separated by hyphen, lowercase, no special characters.
Examples: "auth-system", "mobile-ui", "bug-fixes", "database-performance", "login-security"
Bad examples: "database", "mobile", "security" (too generic)`;

      const aiTopic = await this.generateCompletion(topicPrompt);
      if (aiTopic) {
        // Clean up AI response
        const cleaned = aiTopic
          .toLowerCase()
          .replace(/[^a-z0-9-]/g, '')
          .replace(/^-+|-+$/g, '')
          .substring(0, 20);
        return cleaned || 'general';
      }
    } catch (error) {
      core.warning(`AI topic generation failed: ${error.message}`);
    }

    // Fallback: extract from discussion title or first PR
    if (data.discussion) {
      return this.extractTopicFromTitle(data.discussion.title);
    } else if (data.prs.length > 0) {
      return this.extractTopicFromTitle(data.prs[0].title);
    } else if (data.issues.length > 0) {
      return this.extractTopicFromTitle(data.issues[0].title);
    } else if (data.jiraIssues.length > 0) {
      return this.extractTopicFromTitle(data.jiraIssues[0].summary);
    }

    return 'general';
  }

  extractTopicFromTitle(title) {
    if (!title) return 'general';

    // Extract meaningful keywords, skip common words
    const skipWords = [
      'the',
      'and',
      'for',
      'with',
      'fix',
      'add',
      'update',
      'improve',
      'bug',
      'issue',
    ];
    const words = title
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .split(/\s+/)
      .filter((word) => word.length > 2 && !skipWords.includes(word))
      .slice(0, 3);

    if (words.length === 0) {
      // If no meaningful words, use first few words
      return (
        title
          .toLowerCase()
          .replace(/[^a-z0-9\s]/g, '')
          .split(/\s+/)
          .slice(0, 3)
          .join('-') || 'general'
      );
    }

    return words.join('-').substring(0, 20);
  }

  async determineSourceFolder(data) {
    const today = new Date().toISOString().split('T')[0];
    const topic = await this.generateAITopic(data);

    // Check if folder exists and add version number if needed
    const fs = require('fs');
    const path = require('path');
    const baseFolder = `${today}-${topic}`;
    const basePath = path.join(process.cwd(), 'generated');

    let folderName = baseFolder;
    let version = 2;

    while (fs.existsSync(path.join(basePath, folderName))) {
      folderName = `${baseFolder}-${version}`;
      version++;
    }

    return folderName;
  }

  generateFileName(docType, data) {
    const timestamp = Date.now();
    const currentDate = new Date().toISOString().split('T')[0];

    if (data.discussion) {
      return `${docType}-${data.discussion.number}.md`;
    } else if (data.prs.length > 0) {
      return `${docType}-pr-${data.prs.map((pr) => pr.number).join('-')}.md`;
    } else if (data.issues.length > 0) {
      return `${docType}-issues-${data.issues
        .map((i) => i.number)
        .join('-')}.md`;
    } else if (data.jiraIssues.length > 0) {
      return `${docType}-jira-${data.jiraIssues
        .map((j) => j.key)
        .join('-')}.md`;
    } else {
      return `${docType}-${currentDate}-${timestamp}.md`;
    }
  }

  createFallbackContent(docType, data, template) {
    let content = template;
    const currentDate = new Date().toISOString().split('T')[0];

    // Replace basic variables
    content = content.replace(/{title}/g, this.generateTitle(docType, data));
    content = content.replace(/{date}/g, currentDate);
    content = content.replace(/{content}/g, this.generateBasicContent(data));
    content = content.replace(/{summary}/g, this.generateBasicSummary(data));

    // Replace discussion number if available
    if (data.discussion && data.discussion.number) {
      content = content.replace(/{discussionNumber}/g, data.discussion.number);
    } else {
      // Create detailed source description for multi-source data
      const sourceDescription = this.generateSourceDescription(data);
      content = content.replace(
        /from GitHub discussion #{discussionNumber}/g,
        sourceDescription
      );
      content = content.replace(
        /from discussion #{discussionNumber}/g,
        sourceDescription
      );
    }

    return content;
  }

  generateSourceDescription(data) {
    const sources = [];

    if (data.prs && data.prs.length > 0) {
      const prNumbers = data.prs.map((pr) => `#${pr.number}`).join(', ');
      sources.push(
        `Pull Request${data.prs.length > 1 ? 's' : ''} ${prNumbers}`
      );
    }

    if (data.issues && data.issues.length > 0) {
      const issueNumbers = data.issues
        .map((issue) => `#${issue.number}`)
        .join(', ');
      sources.push(`Issue${data.issues.length > 1 ? 's' : ''} ${issueNumbers}`);
    }

    if (data.jiraIssues && data.jiraIssues.length > 0) {
      const jiraKeys = data.jiraIssues.map((jira) => jira.key).join(', ');
      sources.push(
        `Jira ticket${data.jiraIssues.length > 1 ? 's' : ''} ${jiraKeys}`
      );
    }

    if (sources.length === 0) {
      return 'from available documentation sources';
    } else if (sources.length === 1) {
      return `from ${sources[0]}`;
    } else if (sources.length === 2) {
      return `from ${sources[0]} and ${sources[1]}`;
    } else {
      const lastSource = sources.pop();
      return `from ${sources.join(', ')}, and ${lastSource}`;
    }
  }

  generateTitle(docType, data) {
    if (data.discussion) {
      return data.discussion.title;
    } else {
      const sourceCount =
        data.prs.length + data.issues.length + data.jiraIssues.length;
      return `${
        docType.charAt(0).toUpperCase() + docType.slice(1)
      } - ${sourceCount} Items`;
    }
  }

  generateBasicContent(data) {
    let content = '';

    if (data.discussion) {
      content += `## Discussion\n${data.discussion.body}\n\n`;
    }

    if (data.prs.length > 0) {
      content += `## Pull Requests\n`;
      data.prs.forEach((pr) => {
        content += `- [PR #${pr.number}](${pr.url}): ${pr.title}\n`;
      });
      content += '\n';
    }

    if (data.issues.length > 0) {
      content += `## Issues\n`;
      data.issues.forEach((issue) => {
        content += `- [Issue #${issue.number}](${issue.url}): ${issue.title}\n`;
      });
      content += '\n';
    }

    if (data.jiraIssues.length > 0) {
      content += `## Jira Issues\n`;
      data.jiraIssues.forEach((issue) => {
        content += `- [${issue.key}](${issue.url}): ${issue.summary}\n`;
      });
      content += '\n';
    }

    return content;
  }

  generateBasicSummary(data) {
    const totalItems =
      (data.discussion ? 1 : 0) +
      data.prs.length +
      data.issues.length +
      data.jiraIssues.length;
    return `Processed ${totalItems} items from ${data.sources.join(
      ', '
    )} sources.`;
  }
}

// CLI execution
if (require.main === module) {
  const generator = new AIDocumentGenerator();
  generator.generateDocument().catch((error) => {
    core.setFailed(error.message);
    process.exit(1);
  });
}

module.exports = { AIDocumentGenerator };
