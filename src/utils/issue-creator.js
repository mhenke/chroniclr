#!/usr/bin/env node

/**
 * GitHub Issue Creator for Action Items
 * Parses action items from discussions and creates assigned GitHub issues
 */

const core = require('@actions/core');
const github = require('@actions/github');

class ActionItemIssueCreator {
  constructor() {
    this.github = github.getOctokit(process.env.GITHUB_TOKEN);
    this.context = github.context;
  }

  /**
   * Parse action items from discussion content
   * Looks for patterns like:
   * - [ ] @username: Task description (Due: Aug 10)
   * - [ ] Task description @username (deadline)
   * - Action Items: @user1, @user2: Description
   */
  parseActionItems(content) {
    const actionItems = [];
    const lines = content.split('\n');
    
    // Patterns to match action items
    const patterns = [
      // Checkbox format: - [ ] @username: Task description (Due: date)
      /^[-*]\s*\[\s*\]\s*@(\w+):\s*(.+?)(?:\s*\(Due:\s*(.+?)\))?$/i,
      // Alternative: - [ ] Task description @username (Due: date)  
      /^[-*]\s*\[\s*\]\s*(.+?)\s*@(\w+)(?:\s*\(Due:\s*(.+?)\))?$/i,
      // Action Items section format: - @username: Description (Due: date)
      /^[-*]\s*@(\w+):\s*(.+?)(?:\s*\(Due:\s*(.+?)\))?$/i,
    ];

    let inActionItemsSection = false;

    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // Check if we're entering an action items section
      if (trimmedLine.toLowerCase().includes('action item')) {
        inActionItemsSection = true;
        continue;
      }
      
      // Exit action items section on new header or empty line after items
      if (trimmedLine.startsWith('#') || (inActionItemsSection && !trimmedLine && actionItems.length > 0)) {
        inActionItemsSection = false;
        continue;
      }

      // Try to match action item patterns
      for (const pattern of patterns) {
        const match = trimmedLine.match(pattern);
        if (match) {
          let assignee, description, dueDate;
          
          if (match[1] && match[2] && !match[1].includes(' ')) {
            // Pattern 1 & 3: @username: description
            assignee = match[1];
            description = match[2];
            dueDate = match[3];
          } else if (match[2] && !match[2].includes(' ')) {
            // Pattern 2: description @username
            description = match[1];
            assignee = match[2];
            dueDate = match[3];
          }

          if (assignee && description) {
            actionItems.push({
              assignee: assignee.replace('@', ''),
              description: description.trim(),
              dueDate: dueDate ? dueDate.trim() : null,
              originalLine: trimmedLine
            });
            break;
          }
        }
      }
    }

    return actionItems;
  }

  /**
   * Create GitHub issue for an action item
   */
  async createIssueForActionItem(actionItem, discussionData) {
    try {
      const title = `[Action Item] ${actionItem.description}`;
      let body = `## Action Item from Discussion\n\n`;
      body += `**Source Discussion**: [${discussionData.title}](${discussionData.url})\n`;
      body += `**Original Action Item**: ${actionItem.originalLine}\n\n`;
      body += `### Description\n${actionItem.description}\n\n`;
      
      if (actionItem.dueDate) {
        body += `### Due Date\n${actionItem.dueDate}\n\n`;
      }
      
      body += `### Context\nThis action item was extracted from discussion #${discussionData.number} and automatically converted to a trackable GitHub issue.\n\n`;
      body += `---\n*Auto-generated by Chroniclr from discussion #${discussionData.number}*`;

      const labels = [
        'action-item',
        'chroniclr-generated', 
        'needs-triage'
      ];

      // Add priority label based on due date
      if (actionItem.dueDate) {
        const dueDate = new Date(actionItem.dueDate);
        const now = new Date();
        const daysUntilDue = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
        
        if (daysUntilDue <= 3) {
          labels.push('priority-high');
        } else if (daysUntilDue <= 7) {
          labels.push('priority-medium');  
        } else {
          labels.push('priority-low');
        }
      }

      const issueParams = {
        owner: this.context.repo.owner,
        repo: this.context.repo.repo,
        title,
        body,
        labels,
      };

      // Add assignee if the user exists
      if (actionItem.assignee) {
        try {
          // Check if user exists and has access to repo
          await this.github.rest.users.getByUsername({
            username: actionItem.assignee
          });
          
          issueParams.assignees = [actionItem.assignee];
          core.info(`Will assign issue to @${actionItem.assignee}`);
        } catch (error) {
          core.warning(`User @${actionItem.assignee} not found or cannot be assigned, creating unassigned issue`);
        }
      }

      const { data: issue } = await this.github.rest.issues.create(issueParams);
      
      core.info(`Created issue #${issue.number}: ${title}`);
      return {
        number: issue.number,
        url: issue.html_url,
        title: issue.title,
        assignee: actionItem.assignee
      };

    } catch (error) {
      core.error(`Failed to create issue for action item: ${error.message}`);
      return null;
    }
  }

  /**
   * Ensure required labels exist in the repository
   */
  async ensureActionItemLabels() {
    const labels = [
      { name: 'action-item', color: 'f29513', description: 'Action items from discussions' },
      { name: 'chroniclr-generated', color: '0e8a16', description: 'Generated by Chroniclr' },
      { name: 'needs-triage', color: 'd4edda', description: 'Needs initial review and categorization' },
      { name: 'priority-high', color: 'd93f0b', description: 'High priority (due within 3 days)' },
      { name: 'priority-medium', color: 'fbca04', description: 'Medium priority (due within 1 week)' },
      { name: 'priority-low', color: '0075ca', description: 'Low priority (due later)' },
    ];

    for (const label of labels) {
      try {
        await this.github.rest.issues.getLabel({
          owner: this.context.repo.owner,
          repo: this.context.repo.repo,
          name: label.name,
        });
      } catch (error) {
        if (error.status === 404) {
          try {
            await this.github.rest.issues.createLabel({
              owner: this.context.repo.owner,
              repo: this.context.repo.repo,
              ...label
            });
            core.info(`Created label: ${label.name}`);
          } catch (createError) {
            core.warning(`Failed to create label ${label.name}: ${createError.message}`);
          }
        }
      }
    }
  }

  /**
   * Process all action items from discussion content
   */
  async processActionItems(discussionData) {
    try {
      core.info('Processing action items from discussion content...');
      
      // Ensure required labels exist
      await this.ensureActionItemLabels();
      
      // Parse action items from discussion content
      const actionItems = this.parseActionItems(discussionData.body);
      
      core.info(`Found ${actionItems.length} action items`);
      
      if (actionItems.length === 0) {
        return { success: true, issues: [], message: 'No action items found' };
      }

      // Create issues for each action item
      const createdIssues = [];
      const failures = [];

      for (const actionItem of actionItems) {
        core.info(`Processing: ${actionItem.description} (assigned to: ${actionItem.assignee || 'unassigned'})`);
        
        const issue = await this.createIssueForActionItem(actionItem, discussionData);
        if (issue) {
          createdIssues.push(issue);
        } else {
          failures.push(actionItem);
        }
      }

      const summary = {
        success: true,
        issues: createdIssues,
        failures,
        message: `Created ${createdIssues.length} issues from ${actionItems.length} action items`
      };

      // Log summary
      core.info(`Action Item Processing Summary:`);
      core.info(`- Total action items found: ${actionItems.length}`);
      core.info(`- Issues created successfully: ${createdIssues.length}`);
      core.info(`- Failures: ${failures.length}`);
      
      if (createdIssues.length > 0) {
        core.info('Created issues:');
        createdIssues.forEach(issue => {
          core.info(`  - Issue #${issue.number}: ${issue.title} (${issue.url})`);
        });
      }

      return summary;

    } catch (error) {
      core.error(`Failed to process action items: ${error.message}`);
      return { success: false, error: error.message, issues: [] };
    }
  }
}

async function main() {
  try {
    const discussionData = {
      number: process.env.DISCUSSION_NUMBER,
      title: process.env.DISCUSSION_TITLE,
      body: process.env.DISCUSSION_BODY,
      url: process.env.DISCUSSION_URL,
      author: process.env.DISCUSSION_AUTHOR
    };

    if (!discussionData.number || !discussionData.body) {
      core.setFailed('Missing required discussion data');
      return;
    }

    const issueCreator = new ActionItemIssueCreator();
    const result = await issueCreator.processActionItems(discussionData);
    
    // Set outputs for use in other workflow steps
    core.setOutput('issues_created', result.issues.length);
    core.setOutput('issues', JSON.stringify(result.issues));
    core.setOutput('success', result.success);
    core.setOutput('message', result.message);

    if (result.success) {
      core.info(result.message);
    } else {
      core.setFailed(result.error);
    }

  } catch (error) {
    core.setFailed(`Action item processing failed: ${error.message}`);
  }
}

if (require.main === module) {
  main();
}

module.exports = { ActionItemIssueCreator };